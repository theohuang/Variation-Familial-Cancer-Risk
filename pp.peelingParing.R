#' Peeling and Paring Function
#' 
#' Returns the posterior genotypic distribution for the proband.
#' @param ped a pedigree containing AT LEAST the following columns: ID, MotherID, 
#' FatherID, and isProband. 
#' isProband is a binary indicator; 1 designates the proband.
#' @param prevs a vector of mutation prevalences. Length determines the number 
#' of genes considered (K), order corresponds to the order in the binary genotype 
#' representation in LIK.
#' @param LIK a likelihood matrix. Rows represent individuals, columns represent 
#' the conditional probability of that individual's observed outcome, given that 
#' they have that column's genotype
#' @param T the maximum number of simultaneous mutations to consider. Genotypes 
#' with more than T mutations are disregarded.
#' @param counselee.id the ID number of the proband (if different from ped or 
#' unspecified). Defaults to the first occurrence of a proband in \code{ped$isProband}
#' @param normalize if TRUE, the posterior genotypic distribution will be normalized
#' so that it sums to 1
#' @details Author: Tom Madsen
#' 
#' NOTE: be careful with the ordering of the columns/genotypes! Need to 
#' correspond to rows of admissible genotypes (\code{PG}), generated by 
#' \code{pp.possibleGenotypes}.
#' @family peeling exported
#' @export
pp.peelingParing = function(ped, prevs, LIK, T, 
                            counselee.id = ped$ID[ped$isProband==1][1],
                            normalize = TRUE){
  
  K = length(prevs)
  PG = pp.possibleGenotypes(K,T)
  #quick way of extracting the total number of admissible genotypes under the approximation
  U = nrow(PG) 
  
  # Edge matrix is a binary matrix that indicates which individuals are mated
  E = pp.edgeMatrix(ped)
  spouses = ped$ID[E[ped$ID==counselee.id,]==1] # Assumes symmetry of edge matrix
  if (length(spouses)==0){ # If proband is unmarried/spouse is missing, set spouse to themself
    spouses=counselee.id
  }
  C = pp.childMatrix(ped)
  
  prev = pp.prevalences(prevs,PG)
  TR = pp.inheritanceProb(PG)
  
  # 3D array whose (i,j,k)th component stores p_ij(u_k)
  P <<- pp.initializeP(PG,E)
  # matrix with (n individuals) rows and |U| columns, where the (i,j)th entry stores 
  # anterior probability(i,u_j)
  A <<- pp.initializeA(PG,ped,prev)
  
  posterior_probs = pp.ant(counselee.id, ped, E, C, prev, LIK, TR)*
    LIK[ped$ID==counselee.id,]*
    apply(sapply(spouses, pp.sub, 
                 index=counselee.id, ped=ped, E=E, C=C, prev=prev, LIK=LIK, TR=TR), 
          1, prod)
  if(normalize == TRUE){
    posterior_probs = posterior_probs/sum(posterior_probs) #normalize
  }
  return(posterior_probs)
}